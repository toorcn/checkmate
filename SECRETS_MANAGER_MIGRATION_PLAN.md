# AWS Secrets Manager Migration Plan

## Overview
This document outlines the plan to refactor the application from using `.env.local` variables to AWS Secrets Manager for secure credential management in production.

**Reference**: Based on [AWS re:Post: Managing secrets for NextJS on Amplify](https://repost.aws/questions/QU-TNFloIaQA-X8FRGCay8-g/how-to-manage-secrets-for-a-nextjs-14-app-built-and-hosted-via-amplify)

### üîë Key Design Decision: Hybrid Approach

**Strategy**: Store only sensitive credentials in Secrets Manager; keep non-sensitive configuration in environment variables.

| Component | Secrets Manager | Environment Variables |
|-----------|----------------|----------------------|
| **Database** | `username`, `password` | `DB_HOST`, `DB_PORT`, `DB_NAME` |
| **Auth** | `AUTH_SECRET` | - |
| **APIs** | `FIRECRAWL_API_KEY`, `EXA_API_KEY` | - |
| **Redis** | `REDIS_PASSWORD` | `REDIS_HOST`, `REDIS_PORT`, `REDIS_MODE` |

**Benefits**:
- ‚úÖ Maximum security for credentials with automatic rotation support
- ‚úÖ Flexibility to change connection details without secret updates
- ‚úÖ Cost efficiency (fewer Secrets Manager API calls)
- ‚úÖ Simplicity in managing non-sensitive configurations

---

## Current State

### Environment Variables in Use
Based on codebase analysis, the following environment variables are currently used:

#### **Secrets (Migrate to Secrets Manager)** üîê
1. ~~`DATABASE_URL`~~ ‚Üí Split into:
   - **Secrets Manager**: `username`, `password` (from RDS secret)
   - **Environment Variable**: `DB_HOST`, `DB_PORT`, `DB_NAME`
2. `AUTH_SECRET` - JWT signing secret for local auth
3. `FIRECRAWL_API_KEY` - Firecrawl API key for content scraping
4. `EXA_API_KEY` - Exa API key for web research
5. `REDIS_PASSWORD` - ElastiCache Redis password (optional, currently empty)

#### **AWS Credentials** üîë
6. `AWS_ACCESS_KEY_ID` / `APP_ACCESS_KEY_ID`:
   - **Production**: ‚ùå Not needed (use IAM roles)
   - **Local Dev**: ‚úÖ Keep in `.env.local` OR use AWS CLI profile
7. `AWS_SECRET_ACCESS_KEY` / `APP_SECRET_ACCESS_KEY`:
   - **Production**: ‚ùå Not needed (use IAM roles)
   - **Local Dev**: ‚úÖ Keep in `.env.local` OR use AWS CLI profile

#### **Configuration (Remain as environment variables)** ‚öôÔ∏è
- `APP_REGION` / `AWS_REGION` - AWS region
- `DB_HOST` - Database host (non-sensitive)
- `DB_PORT` - Database port (default: 5432)
- `DB_NAME` - Database name (default: checkmate)
- `S3_BUCKET` - S3 bucket name for media uploads
- `BEDROCK_MODEL_ID` - Bedrock model identifier
- `REDIS_MODE` - Redis mode (single/cluster)
- `REDIS_HOST` - Redis host endpoint
- `REDIS_PORT` - Redis port
- `REDIS_TLS` - Redis TLS setting
- `REDIS_KEY_PREFIX` - Redis key prefix
- Feature flags (ENABLE_DETAILED_LOGGING, ENABLE_CACHE, etc.)
- Timeout configurations

### Current Secrets in AWS Secrets Manager

| Secret Name | Content | Status | Usage | Action |
|------------|---------|---------|-------|--------|
| `rds!db-663b916d-667d-420b-930f-bbdbf25c9eb8` | `username`, `password` | ‚úÖ Populated | `lib/db/index.ts` | **Use this** |
| `checkmate-dev/firecrawl_api_key` | Firecrawl API key | ‚úÖ Populated | `tools/helpers.ts` | Use |
| `checkmate-dev/auth_secret` | Auth secret key | ‚úÖ Populated | `lib/auth.ts` | Use |
| `checkmate-dev/exa_api_key` | Exa API key | ‚úÖ Populated | `tools/fact-checking/web-research.ts` | Use |
| `checkmate-dev/database_url` | ~~Full connection string~~ | ‚ö†Ô∏è Empty | - | **Ignore** (use RDS secret instead) |
| `checkmate-dev/redis_password` | Redis password | ‚ö†Ô∏è Empty | `lib/redis.ts` | **Defer** (not configured yet) |

**RDS Secret Structure** (Auto-generated by RDS):
```json
{
  "username": "postgres",
  "password": "_rXmmBlicDx$CysuR]$c|MhUurv4"
}
```

**Note**: The RDS secret only contains `username` and `password`. Other connection details (`host`, `port`, `dbname`) are non-sensitive and will remain as environment variables.

---

## Migration Strategy

### Hybrid Approach: Secrets + Configuration

This migration uses a **hybrid approach** for optimal security and flexibility:

**From Secrets Manager** (sensitive data):
- Database credentials (username, password)
- Auth secrets (JWT signing keys)
- API keys (Firecrawl, Exa)
- Redis password (when configured)

**From Environment Variables** (non-sensitive configuration):
- Database connection details (host, port, dbname)
- AWS region, S3 bucket
- Feature flags and timeouts
- Redis connection details (host, port, mode)

This approach provides:
‚úÖ **Security**: Credentials never in plaintext in environment  
‚úÖ **Flexibility**: Connection details can change without secret rotation  
‚úÖ **Cost Efficiency**: Fewer Secrets Manager API calls  
‚úÖ **Simplicity**: Easy to update non-sensitive configs

### Phase 1: Setup Secrets Manager Client
**Objective**: Create a centralized secrets retrieval utility

**Tasks**:
1. ‚úÖ Install AWS SDK for Secrets Manager
   ```bash
   npm install @aws-sdk/client-secrets-manager
   ```

2. ‚úÖ Create `lib/secrets/index.ts` - Centralized secrets manager client
   - Implement secrets caching to reduce API calls
   - Add error handling and retry logic
   - Support both development and production environments

3. ‚úÖ Create `lib/secrets/types.ts` - Type definitions for secrets
   - Define interfaces for each secret structure
   - Add validation schemas using Zod

**Files to Create**:
- `lib/secrets/index.ts`
- `lib/secrets/types.ts`
- `lib/secrets/cache.ts` (optional: in-memory cache for secrets)

---

### Phase 2: Database Configuration Migration
**Objective**: Replace database credentials with Secrets Manager using hybrid approach

**Current Usage**:
- `lib/db/index.ts` - Direct `process.env.DATABASE_URL` access
- `drizzle.config.ts` - Migration configuration

**Hybrid Approach**:
- **From Secrets Manager**: `username`, `password` (from RDS secret)
- **From Environment Variables**: `DB_HOST`, `DB_PORT`, `DB_NAME`

**Tasks**:
1. ‚úÖ Retrieve credentials from RDS secret (`rds!db-663b916d-667d-420b-930f-bbdbf25c9eb8`)
2. ‚úÖ Add new environment variables to `env.example`:
   - `DB_HOST=checkmate-db-instance.c2f2oys8o2re.us-east-1.rds.amazonaws.com`
   - `DB_PORT=5432`
   - `DB_NAME=checkmate`
3. ‚úÖ Modify `lib/db/index.ts`:
   - Fetch credentials from Secrets Manager
   - Get connection details from environment variables
   - Construct connection string: `postgres://${username}:${password}@${host}:${port}/${dbname}`
   - Add connection validation
4. ‚úÖ Update `drizzle.config.ts` to support async secret loading
5. ‚úÖ Test database connectivity in both dev and production

**Example Implementation**:
```typescript
// lib/db/index.ts
import { getSecret } from '@/lib/secrets';

async function getDatabaseUrl(): Promise<string> {
  const { username, password } = await getSecret('rds!db-663b916d-667d-420b-930f-bbdbf25c9eb8');
  const host = process.env.DB_HOST!;
  const port = process.env.DB_PORT || '5432';
  const dbname = process.env.DB_NAME!;
  
  return `postgres://${username}:${encodeURIComponent(password)}@${host}:${port}/${dbname}?sslmode=require`;
}
```

**Benefits of Hybrid Approach**:
- ‚úÖ Credentials secured in Secrets Manager with automatic rotation
- ‚úÖ Connection details easily updated via environment variables
- ‚úÖ No need to update secrets when switching databases/hosts

---

### Phase 3: Authentication Secret Migration
**Objective**: Replace `AUTH_SECRET` with Secrets Manager

**Current Usage**:
- `lib/auth.ts` - JWT signing via `process.env.AUTH_SECRET`

**Tasks**:
1. ‚úÖ Update `lib/auth.ts`:
   - Replace `process.env.AUTH_SECRET` with Secrets Manager retrieval
   - Add caching to avoid fetching on every request
   - Implement fallback for development
2. ‚úÖ Verify JWT signing/verification still works
3. ‚úÖ Test authentication flow end-to-end

**Migration Pattern**:
```typescript
// Before
const secret = process.env.AUTH_SECRET || "dev-insecure-secret";

// After
const secret = await getSecret("checkmate-dev/auth_secret");
```

---

### Phase 4: API Keys Migration
**Objective**: Replace `FIRECRAWL_API_KEY` and `EXA_API_KEY` with Secrets Manager

**Current Usage**:
- `tools/helpers.ts` - Firecrawl client initialization
- `tools/fact-checking/web-research.ts` - Exa API calls
- `lib/config.ts` - Validation schema

**Tasks**:
1. ‚úÖ Update `lib/config.ts`:
   - Remove API keys from required schema validation
   - Keep validation in runtime when secrets are loaded
2. ‚úÖ Update `tools/helpers.ts`:
   - Replace `process.env.FIRECRAWL_API_KEY` with Secrets Manager
3. ‚úÖ Update `tools/fact-checking/web-research.ts`:
   - Replace `process.env.EXA_API_KEY` with Secrets Manager
4. ‚úÖ Test API integrations:
   - Firecrawl web scraping
   - Exa research queries

---

### Phase 5: Redis Configuration Migration
**Objective**: Replace `REDIS_PASSWORD` with Secrets Manager (when populated)

**Current Usage**:
- `lib/redis.ts` - Redis client initialization

**Hybrid Approach** (Same as Database):
- **From Secrets Manager**: `REDIS_PASSWORD` (credentials only)
- **From Environment Variables**: `REDIS_HOST`, `REDIS_PORT`, `REDIS_MODE`, `REDIS_TLS`, `REDIS_KEY_PREFIX`

**Tasks**:
1. ‚è∏Ô∏è **DEFERRED** - Redis password secret is currently empty
2. ‚úÖ Prepare code structure to support Secrets Manager retrieval
3. ‚úÖ Update `lib/redis.ts` to check Secrets Manager first, fall back to env var
4. ‚úÖ Keep connection details (host, port, mode) in environment variables
5. üìù Document process for when Redis is fully configured

**Example Implementation**:
```typescript
// lib/redis.ts
import { getSecret } from '@/lib/secrets';

async function getRedisPassword(): Promise<string | undefined> {
  if (process.env.USE_SECRETS_MANAGER === 'true') {
    const secret = await getSecret('checkmate-dev/redis_password');
    return secret?.password;
  }
  return process.env.REDIS_PASSWORD;
}

// Then use in Redis client initialization
const password = await getRedisPassword();
const host = process.env.REDIS_HOST;
const port = process.env.REDIS_PORT || '6379';
```

**Note**: This is optional until Redis is fully configured in production.

---

### Phase 6: AWS Credentials Migration
**Objective**: Use IAM roles in production, AWS profiles for local development

**Current Usage**:
- `lib/ai.ts` - Manual credential mapping for Bedrock
- AWS SDK clients use default credential chain

**Strategy**: Different approaches for different environments

#### Production (Amplify/ECS/Lambda):
‚úÖ **Use IAM Roles** (no hardcoded credentials)
- Attach IAM role to Amplify deployment
- Role-based authentication for all AWS services
- No `AWS_ACCESS_KEY_ID` or `AWS_SECRET_ACCESS_KEY` needed

#### Local Development:
‚úÖ **Use AWS CLI Profiles** (recommended) OR Environment Variables

**Option A - AWS CLI Profile (Recommended)**:
```bash
# ~/.aws/credentials
[default]
aws_access_key_id = YOUR_DEV_KEY
aws_secret_access_key = YOUR_DEV_SECRET

# ~/.aws/config
[default]
region = us-east-1
```

**Option B - Environment Variables**:
```bash
# .env.local (for local dev only, never commit)
AWS_ACCESS_KEY_ID=your-dev-key
AWS_SECRET_ACCESS_KEY=your-dev-secret
# OR keep the app-specific naming
APP_ACCESS_KEY_ID=your-dev-key
APP_SECRET_ACCESS_KEY=your-dev-secret
```

**Tasks**:
1. ‚úÖ Update `lib/ai.ts` to use AWS SDK default credential chain:
   - Production: Uses IAM role automatically
   - Local: Falls back to AWS CLI profile or env vars
2. ‚úÖ Remove manual credential mapping code in `lib/ai.ts`
3. ‚úÖ Update `lib/aws.ts` to rely on default credential chain
4. ‚úÖ Configure IAM roles for production:
   - Amplify deployment environment
   - ECS tasks (if applicable)
   - Lambda functions (if applicable)
5. ‚úÖ Update documentation for local development setup
6. ‚úÖ Add IAM policies for Secrets Manager access

**AWS SDK Credential Chain** (automatic priority):
1. Environment variables (`AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`)
2. AWS CLI profile (`~/.aws/credentials`)
3. IAM role (in production - ECS, EC2, Lambda, Amplify)
4. Container credentials (ECS)
5. Instance metadata (EC2)

**IAM Role Policy Required** (for Production):
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "secretsmanager:GetSecretValue",
        "secretsmanager:DescribeSecret"
      ],
      "Resource": [
        "arn:aws:secretsmanager:us-east-1:*:secret:checkmate-dev/*",
        "arn:aws:secretsmanager:us-east-1:*:secret:rds!db-663b916d-667d-420b-930f-bbdbf25c9eb8*"
      ]
    },
    {
      "Effect": "Allow",
      "Action": [
        "s3:PutObject",
        "s3:GetObject",
        "s3:ListBucket"
      ],
      "Resource": [
        "arn:aws:s3:::your-bucket-name",
        "arn:aws:s3:::your-bucket-name/*"
      ]
    },
    {
      "Effect": "Allow",
      "Action": [
        "transcribe:StartTranscriptionJob",
        "transcribe:GetTranscriptionJob"
      ],
      "Resource": "*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "bedrock:InvokeModel"
      ],
      "Resource": "*"
    }
  ]
}
```

**Code Changes**:
```typescript
// lib/ai.ts - BEFORE (manual mapping)
if (process.env.APP_ACCESS_KEY_ID && !process.env.AWS_ACCESS_KEY_ID) {
  process.env.AWS_ACCESS_KEY_ID = process.env.APP_ACCESS_KEY_ID;
}

// lib/ai.ts - AFTER (use SDK default chain)
// Remove manual mapping - AWS SDK handles it automatically
```

---

### Phase 7: Configuration Refactoring
**Objective**: Update configuration management to work with Secrets Manager

**Current Files**:
- `lib/config.ts` - Central configuration with Zod validation
- `env.example` - Environment variable template

**Tasks**:
1. ‚úÖ Create `lib/config/index.ts` - New async configuration loader
2. ‚úÖ Split configuration into:
   - **Secrets** (from Secrets Manager)
   - **Configuration** (from environment variables)
3. ‚úÖ Update `lib/config.ts` to support async initialization
4. ‚úÖ Add configuration preloading strategy:
   - Option A: Load on app startup (recommended)
   - Option B: Load lazily on first use
5. ‚úÖ Update all imports across codebase

**New Configuration Structure** (Hybrid Approach):
```typescript
// lib/secrets/types.ts - Secrets from Secrets Manager
export interface RDSCredentials {
  username: string;
  password: string;
}

export interface AuthSecret {
  secret: string;
  adminEmail?: string;
  adminPassword?: string;
}

export interface APIKeys {
  firecrawl: string;
  exa: string;
}

export interface RedisSecret {
  password?: string;
}

export interface AppSecrets {
  database: RDSCredentials;
  auth: AuthSecret;
  apiKeys: APIKeys;
  redis?: RedisSecret;
}

// lib/config/environment.ts - Non-secret configuration
export interface DatabaseConfig {
  host: string;
  port: number;
  name: string;
}

export interface AppConfig {
  region: string;
  s3Bucket: string;
  bedrockModelId: string;
  database: DatabaseConfig;
  redis: {
    mode: string;
    host: string;
    port: number;
    tls: boolean;
    keyPrefix: string;
  };
  // ... other configs
}

// lib/db/index.ts - Usage example
import { getSecret } from '@/lib/secrets';
import { RDSCredentials } from '@/lib/secrets/types';

async function buildDatabaseUrl(): Promise<string> {
  const credentials: RDSCredentials = await getSecret('rds!db-663b916d-667d-420b-930f-bbdbf25c9eb8');
  
  const host = process.env.DB_HOST!;
  const port = process.env.DB_PORT || '5432';
  const dbname = process.env.DB_NAME || 'checkmate';
  
  return `postgres://${credentials.username}:${encodeURIComponent(credentials.password)}@${host}:${port}/${dbname}?sslmode=require`;
}
```

---

### Phase 8: Development vs Production Handling
**Objective**: Support both local development and production deployment

**Strategy**:

#### 1. **Local Development** üñ•Ô∏è
Keep `.env.local` with:
- `USE_SECRETS_MANAGER=false` (use local env vars)
- Database credentials (for local testing)
- API keys (for local testing)
- **AWS credentials** (either in `.env.local` or AWS CLI profile):
  ```bash
  # Option A: In .env.local
  AWS_ACCESS_KEY_ID=your-dev-key
  AWS_SECRET_ACCESS_KEY=your-dev-secret
  
  # Option B: AWS CLI profile (recommended)
  # No env vars needed, SDK uses ~/.aws/credentials
  ```

#### 2. **Production (Amplify/AWS)** ‚òÅÔ∏è
Amplify environment variables:
- `USE_SECRETS_MANAGER=true` (use Secrets Manager)
- Non-sensitive config only:
  ```bash
  DB_HOST=checkmate-db-instance...
  DB_PORT=5432
  DB_NAME=checkmate
  APP_REGION=us-east-1
  S3_BUCKET=your-bucket
  ```
- **NO AWS credentials** (IAM role provides access)
- **NO API keys** (loaded from Secrets Manager)
- **NO DB password** (loaded from Secrets Manager)

#### 3. **Environment Detection** üîç
```typescript
// lib/secrets/index.ts
const isProduction = process.env.NODE_ENV === 'production';
const useSecretsManager = process.env.USE_SECRETS_MANAGER === 'true' || isProduction;

export async function getSecret(secretName: string) {
  if (!useSecretsManager) {
    // Local dev: fall back to environment variables
    return getFallbackFromEnv(secretName);
  }
  
  // Production: fetch from Secrets Manager
  return fetchFromSecretsManager(secretName);
}
```

**Files to Update**:
- `lib/secrets/index.ts` - Add environment detection and fallback logic
- `env.example` - Document local vs production setup
- `README.md` - Update setup instructions with AWS credential options

---

### Phase 9: Testing & Validation
**Objective**: Ensure all integrations work correctly

**Test Checklist**:
- [ ] Database connection and queries
- [ ] Authentication (sign in, sign up, session management)
- [ ] Firecrawl API integration
- [ ] Exa API integration
- [ ] AWS services (S3, Transcribe, Bedrock)
- [ ] Redis connection (when configured)
- [ ] Error handling for missing/invalid secrets
- [ ] Performance (secrets caching)

**Test Environments**:
1. ‚úÖ Local development with `.env.local`
2. ‚úÖ Local development with Secrets Manager
3. ‚úÖ Staging/Production with Secrets Manager

---

### Phase 10: Documentation & Cleanup
**Objective**: Update documentation and remove deprecated code

**Tasks**:
1. ‚úÖ Update `README.md`:
   - Add Secrets Manager setup instructions
   - Document IAM permissions required
   - Add troubleshooting guide
2. ‚úÖ Update `env.example`:
   - Mark secrets with warnings
   - Add comments about Secrets Manager
3. ‚úÖ Create `docs/SECRETS_MANAGEMENT.md`:
   - How to add new secrets
   - How to rotate secrets
   - Best practices
4. ‚úÖ Update `DEVELOPER_ONBOARDING.md`:
   - Add Secrets Manager onboarding steps
5. ‚úÖ Clean up:
   - Remove unused environment variables
   - Remove deprecated code
   - Update `.gitignore` if needed

---

## Implementation Order

### **Sprint 1: Foundation** (Estimated: 2-3 hours)
1. Setup Secrets Manager client (`lib/secrets/`)
2. Implement caching strategy
3. Add type definitions

### **Sprint 2: Core Secrets** (Estimated: 3-4 hours)
4. Migrate Database configuration
5. Migrate Auth secret
6. Test authentication flow

### **Sprint 3: API Keys** (Estimated: 2-3 hours)
7. Migrate Firecrawl API key
8. Migrate Exa API key
9. Test API integrations

### **Sprint 4: Infrastructure** (Estimated: 2-3 hours)
10. Remove AWS credentials from code
11. Configure IAM roles and policies
12. Update AWS SDK clients

### **Sprint 5: Configuration** (Estimated: 2-3 hours)
13. Refactor configuration management
14. Update all imports
15. Add environment detection

### **Sprint 6: Testing & Documentation** (Estimated: 3-4 hours)
16. Comprehensive testing
17. Update documentation
18. Clean up deprecated code

**Total Estimated Time**: 14-20 hours

---

## Risk Mitigation

### Potential Risks
1. **Service Interruption**: Misconfiguration could break production
   - **Mitigation**: Test thoroughly in staging first, implement feature flags

2. **Performance Impact**: Secrets Manager API calls could slow down app startup
   - **Mitigation**: Implement aggressive caching, preload secrets on startup

3. **Cost**: Secrets Manager has associated costs ($0.40/secret/month + $0.05/10,000 API calls)
   - **Mitigation**: Implement caching to minimize API calls, monitor costs

4. **IAM Permissions**: Incorrect permissions could prevent secret access
   - **Mitigation**: Document required permissions clearly, test in staging

5. **Secret Rotation**: Automatic rotation could break app if not handled
   - **Mitigation**: Implement graceful secret refresh, monitor for rotation events

### Rollback Strategy
1. Keep `.env.local` pattern as fallback
2. Use feature flag `USE_SECRETS_MANAGER` to toggle
3. Maintain backward compatibility during transition
4. Have deployment rollback plan ready

---

## Success Criteria

### Functional Requirements
- ‚úÖ All secrets loaded from Secrets Manager in production
- ‚úÖ No sensitive data in environment variables
- ‚úÖ Local development still works with `.env.local`
- ‚úÖ All existing features continue to work
- ‚úÖ Performance impact < 500ms on cold start

### Non-Functional Requirements
- ‚úÖ Code is well-documented and maintainable
- ‚úÖ Team is trained on new secret management process
- ‚úÖ Monitoring and alerting configured
- ‚úÖ Secret rotation process documented

---

## Post-Migration Tasks

1. **Delete Secrets from Code/Docs**:
   - Remove any hardcoded secrets from git history (if applicable)
   - Rotate any secrets that were previously in version control

2. **Enable Secret Rotation**:
   - Configure automatic rotation for RDS credentials
   - Set up rotation Lambda for other secrets

3. **Monitoring**:
   - Set up CloudWatch alarms for Secrets Manager API errors
   - Monitor secret access patterns
   - Alert on unauthorized access attempts

4. **Security Audit**:
   - Review IAM policies for least privilege
   - Audit which services have access to which secrets
   - Document secret access patterns

5. **Team Training**:
   - Train team on new secrets workflow
   - Document how to add/update secrets
   - Create runbook for common issues

---

## Files to Modify

### New Files
- `lib/secrets/index.ts` - Secrets Manager client
- `lib/secrets/types.ts` - Secret type definitions
- `lib/secrets/cache.ts` - Caching layer
- `docs/SECRETS_MANAGEMENT.md` - Documentation
- `SECRETS_MANAGER_MIGRATION_PLAN.md` - This file

### Files to Modify
- `lib/db/index.ts` - Database connection
- `lib/auth.ts` - Authentication
- `lib/redis.ts` - Redis connection
- `lib/ai.ts` - AWS credentials
- `lib/aws.ts` - AWS SDK clients
- `lib/config.ts` - Configuration management
- `tools/helpers.ts` - Firecrawl integration
- `tools/fact-checking/web-research.ts` - Exa integration
- `drizzle.config.ts` - Drizzle configuration
- `env.example` - Environment template
- `README.md` - Setup instructions
- `docs/DEVELOPER_ONBOARDING.md` - Onboarding guide

### Files to Review (May need updates)
- `middleware.ts` - May need async handling
- `app/api/**/*.ts` - API routes that use secrets
- All files that import from `lib/config.ts`

---

## Secrets Manager Secret Structure

### Recommended Secret Names (Standardized)
```
rds!db-663b916d-667d-420b-930f-bbdbf25c9eb8  (RDS auto-generated - use this)
checkmate-{environment}/auth
checkmate-{environment}/api-keys
checkmate-{environment}/redis
```

### Secret JSON Structures

#### `rds!db-663b916d-667d-420b-930f-bbdbf25c9eb8` (RDS Auto-Generated)
**Use this secret directly - it only contains credentials:**
```json
{
  "username": "postgres",
  "password": "_rXmmBlicDx$CysuR]$c|MhUurv4"
}
```

**Corresponding Environment Variables** (non-sensitive):
```bash
DB_HOST=checkmate-db-instance.c2f2oys8o2re.us-east-1.rds.amazonaws.com
DB_PORT=5432
DB_NAME=checkmate
```

#### `checkmate-dev/auth`
```json
{
  "secret": "your-auth-secret-here",
  "adminEmail": "admin@example.com",
  "adminPassword": "hashed-admin-password"
}
```

#### `checkmate-dev/api-keys`
```json
{
  "firecrawl": "fc-your-key-here",
  "exa": "your-exa-key-here"
}
```

#### `checkmate-dev/redis` (Optional)
```json
{
  "password": "your-redis-password",
  "url": "rediss://default:password@your-cluster.cache.amazonaws.com:6379"
}
```

---

## Reference Links

- [AWS re:Post: NextJS Secrets Management](https://repost.aws/questions/QU-TNFloIaQA-X8FRGCay8-g/how-to-manage-secrets-for-a-nextjs-14-app-built-and-hosted-via-amplify)
- [AWS Secrets Manager Documentation](https://docs.aws.amazon.com/secretsmanager/)
- [AWS SDK for JavaScript v3 - Secrets Manager](https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/clients/client-secrets-manager/)
- [Amplify Environment Variables](https://docs.aws.amazon.com/amplify/latest/userguide/environment-variables.html)

---

## Notes

- **Terraform Directory**: As per requirements, ignore `infra/terraform/` directory
- **Secret Naming**: Using `checkmate-dev/` prefix for dev environment; use `checkmate-prod/` for production
- **RDS Secret**: Auto-generated RDS secret (`rds!db-...`) should be used directly rather than duplicating
- **Cost Optimization**: Implement in-memory caching to minimize Secrets Manager API calls (can reduce costs by 90%+)

---

## Summary: What Gets Stored Where

### üîê In AWS Secrets Manager (Sensitive Credentials)

| Secret Name | Contains | Why |
|------------|----------|-----|
| `rds!db-663b916d-667d-420b-930f-bbdbf25c9eb8` | DB username & password | Credentials; supports auto-rotation |
| `checkmate-dev/auth_secret` | JWT signing key | Sensitive auth secret |
| `checkmate-dev/firecrawl_api_key` | Firecrawl API key | Third-party API credential |
| `checkmate-dev/exa_api_key` | Exa API key | Third-party API credential |
| `checkmate-dev/redis_password` | Redis password | Credentials (when configured) |

### ‚öôÔ∏è In Environment Variables (Non-Sensitive Config)

#### Production (Amplify)
```bash
# Database connection (non-sensitive)
DB_HOST=checkmate-db-instance.c2f2oys8o2re.us-east-1.rds.amazonaws.com
DB_PORT=5432
DB_NAME=checkmate

# AWS Configuration
APP_REGION=us-east-1
S3_BUCKET=your-bucket-name
BEDROCK_MODEL_ID=us.amazon.nova-lite-v1:0

# Redis Connection (non-sensitive)
REDIS_HOST=your-redis-host
REDIS_PORT=6379
REDIS_MODE=single
REDIS_TLS=true
REDIS_KEY_PREFIX=cm:

# Feature Flags
ENABLE_DETAILED_LOGGING=false
ENABLE_CACHE=true
ENABLE_MONITORING=true

# Secrets Manager Control
USE_SECRETS_MANAGER=true
NODE_ENV=production

# NO AWS CREDENTIALS (uses IAM role automatically)
```

#### Local Development (.env.local)
```bash
# Same as production, PLUS:

# Secrets Manager Control (use local env vars)
USE_SECRETS_MANAGER=false
NODE_ENV=development

# AWS Credentials (for local development)
# Option A: Set here
AWS_ACCESS_KEY_ID=your-dev-key
AWS_SECRET_ACCESS_KEY=your-dev-secret

# Option B: Use AWS CLI profile instead (~/.aws/credentials)
# If using CLI profile, don't set AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY

# Local secrets (since USE_SECRETS_MANAGER=false)
DATABASE_URL=postgres://username:password@host:5432/dbname
AUTH_SECRET=your-local-auth-secret
FIRECRAWL_API_KEY=your-firecrawl-key
EXA_API_KEY=your-exa-key
REDIS_PASSWORD=your-redis-password
```

### üîÑ Runtime Construction

**Database Connection String** is built at runtime:
```typescript
// Fetch from Secrets Manager
const { username, password } = await getSecret('rds!db-...');

// Get from environment
const host = process.env.DB_HOST;
const port = process.env.DB_PORT;
const dbname = process.env.DB_NAME;

// Construct connection string
const url = `postgres://${username}:${encodeURIComponent(password)}@${host}:${port}/${dbname}?sslmode=require`;
```

**Benefits of this approach**:
- üîí Credentials never in plaintext environment variables
- üîÑ Database host/port can change without rotating secrets
- üí∞ Cost-efficient (fewer secrets stored)
- üîÅ Supports automatic credential rotation
- üõ†Ô∏è Easy to manage infrastructure changes

---

**Status**: üìã Planning Complete - Ready for Implementation
**Last Updated**: October 5, 2025
**Owner**: Development Team

